<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!--
*************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
*************************************************************************
-->

  <Import Project="Microsoft.VsSDK.Common.targets" />

  <UsingTask TaskName="CtoResourceMerger" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="MPLex" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="CreatePkgDef" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="CopyIfChanged" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="VsTemplatePaths" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="CalculateZipItems" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="GetVSTemplateItems" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="ZipItems" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="EnableExtension" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="EnableLoadingAllExtensions" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="FindInstalledExtension" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="UninstallExtension" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="FindVsixManifest" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="GetExtensionsPath" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="GetDeploymentPathFromVsixManifest" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="CreateZipPackage" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="ReadReferencesFromVsixManifest" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="DetokenizeVsixManifestSource" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="ValidateVsixManifest" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="Devenv" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="CheckProfileSetup" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="CreateVsixSourceItemFromReferences" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />
  <UsingTask TaskName="SplitIncludeOutputGroupsInVSIX" AssemblyFile="Microsoft.VsSDK.Build.Tasks.dll" />

  <PropertyGroup>
    <DeployVSTemplates Condition="'$(DeployVSTemplates)' == ''">true</DeployVSTemplates>
    <GetVsixItemsToBundleDependsOn>$(GetVsixItemsToBundleDependsOn);Compile</GetVsixItemsToBundleDependsOn>
    <DeployVsixExtensionFilesDependsOn>$(DeployVsixExtensionFilesDependsOn);Compile</DeployVsixExtensionFilesDependsOn>
    <ExtensionsDeploymentSubPath Condition="'$(ExtensionsDeploymentSubPath)' == ''">Microsoft\VisualStudio\$(VSSDKTargetPlatformVersion)$(VSSDKTargetPlatformRegRootSuffix)\Extensions\</ExtensionsDeploymentSubPath>
    <TargetVSVersion Condition="'$(TargetVSVersion)' == ''">$(VSSDKTargetPlatformVersion)</TargetVSVersion>
    <DeployExtension Condition="'$(DeployExtension)' == ''">true</DeployExtension>
    <CopyVsixExtensionFiles Condition="'$(CopyVsixExtensionFiles)'==''">false</CopyVsixExtensionFiles>
    <CreateVsixContainer Condition="'$(CreateVsixContainer)' == ''">true</CreateVsixContainer>
    <CopyVsixManifestToOutput Condition="'$(CopyVsixManifestToOutput)' == '' and ('$(CreateVsixContainer)' != 'false' or '$(DeployExtension)' != 'false' or '$(CopyVsixExtensionFiles)' != 'false')">true</CopyVsixManifestToOutput>
  </PropertyGroup>

  <!--
    =================================================================================
                          Find Source Vsix Manifest File
    =================================================================================
    -->
  <Target Name="FindSourceVsixManifest">
    <FindVsixManifest ItemsToConsider="@(None)">
      <Output TaskParameter="VsixManifest" ItemName="SourceVsixManifest"/>
    </FindVsixManifest>
  </Target>

  <!--
    =================================================================================
                          Validate Source Vsix Manifest File
    =================================================================================
    -->
  <PropertyGroup>
    <ValidateVsixManifestDependsOn>$(ValidateVsixManifestDependsOn);FindSourceVsixManifest</ValidateVsixManifestDependsOn>
    <BypassVsixValidation Condition="'$(BypassVsixValidation)' == ''">false</BypassVsixValidation>
    <VsixSchemaPath Condition="'$(VsixSchemaPath)' == ''"></VsixSchemaPath>
  </PropertyGroup>
  <Target Name="ValidateVsixManifest" DependsOnTargets="$(ValidateVsixManifestDependsOn)">
    <ValidateVsixManifest Condition="Exists('@(SourceVsixManifest)')" ItemToValidate="@(SourceVsixManifest)" BypassVsixValidation="$(BypassVsixValidation)" VsixSchemaPath="$(VsixSchemaPath)">
    </ValidateVsixManifest>
  </Target>

  <!--
    =================================================================================
                          Detokenize Source Vsix Manifest File
    =================================================================================

    Detokenize the source.extension.vsixmanifest file to the intermediate directory as extension.vsixmanifest
    -->
  <PropertyGroup>
    <DetokenizeVsixManifestFileDependsOn>$(DetokenizeVsixManifestFileDependsOn);AssignProjectConfiguration;FindSourceVsixManifest;ValidateVsixManifest</DetokenizeVsixManifestFileDependsOn>
    <VsixManifestFileName Condition="'$(VsixManifestFileName)' == ''">extension.vsixmanifest</VsixManifestFileName>
    <IntermediateVsixManifest Condition="'$(IntermediateVsixManifest)' == ''">$(IntermediateOutputPath)$(VsixManifestFileName)</IntermediateVsixManifest>
  </PropertyGroup>
  <Target Name="DetokenizeVsixManifestFile"
          DependsOnTargets="$(DetokenizeVsixManifestFileDependsOn)">

    <ItemGroup>
      <!-- Include Project to Project references -->
      <_VsixManifestProjectReference Include="@(ProjectReferenceWithConfiguration)" />
      <!-- Include this project so that the source.extension.vsixmanifest can refer to its own project/assembly -->
      <_VsixManifestProjectReference Include="$(ProjectFileName)">
        <Name>$(ProjectName)</Name>
        <VSIXSubPath>$(AssemblyVSIXSubPath)</VSIXSubPath>
      </_VsixManifestProjectReference>
    </ItemGroup>

    <ReadReferencesFromVsixManifest
      InputFile="@(SourceVsixManifest)"
      CurrentProjectName="$(ProjectName)"
      ProjectReferences="@(_VsixManifestProjectReference)">
      <Output TaskParameter="ProjectReferencesToResolve" ItemName="_VsixManifestReferencesToResolve" />
    </ReadReferencesFromVsixManifest>

    <MSBuild Projects="@(_VsixManifestReferencesToResolve)"
         Properties="%(_VsixManifestReferencesToResolve.SetConfiguration); %(_VsixManifestReferencesToResolve.SetPlatform)"
         Targets="%(_VsixManifestReferencesToResolve.OutputGroupToResolve)"
         RebaseOutputs="true">
      <Output TaskParameter="TargetOutputs" ItemName="_VsixManifestResolvedReferences"/>
    </MSBuild>

    <DetokenizeVsixManifestSource
      InputFile="@(SourceVsixManifest)"
      OutputFile="$(IntermediateVsixManifest)"
      ResolvedReferences="@(_VsixManifestResolvedReferences)">
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </DetokenizeVsixManifestSource>

  </Target>

  <!--
    =================================================================================
                                         Copy Vsix Manifest File
    =================================================================================

    Copy the extensions.vsixmanifest file to the output directory.
    -->
  <PropertyGroup>
    <CopyVsixManifestFileDependsOn>$(CopyVsixManifestFileDependsOn);DetokenizeVsixManifestFile</CopyVsixManifestFileDependsOn>
  </PropertyGroup>
  <Target
      Name="CopyVsixManifestFile"
      Condition="'$(CopyVsixManifestToOutput)'=='true'"
      DependsOnTargets="$(CopyVsixManifestFileDependsOn)">

    <Copy
        SourceFiles="$(IntermediateVsixManifest)"
        DestinationFolder="$(OutDir)"
        SkipUnchangedFiles="true"
        OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
        Retries="$(CopyRetryCount)"
        Condition="Exists('$(IntermediateOutputPath)$(VsixManifestFileName)')"
        RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)">
      <Output TaskParameter="DestinationFiles" ItemName="_VsixOutputManifest"/>
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
    </Copy>

    <Message Importance="Normal" Condition="Exists('$(IntermediateOutputPath)$(VsixManifestFileName)')" Text="$(MSBuildProjectName) -&gt; @(_VsixOutputManifest->'%(FullPath)')" />
  </Target>

  <!--
    =======================================================================================================
                                         Create Vsix Bundle (.vsix file)
    =======================================================================================================
  -->

  <PropertyGroup>
    <TargetVsixContainerName Condition="'$(TargetVsixContainerName)'==''">$(TargetName).vsix</TargetVsixContainerName>
    <TargetVsixContainer Condition="'$(TargetVsixContainer)'==''">$(OutDir)$(TargetVsixContainerName)</TargetVsixContainer>
    <GetVsixSourceItemsDependsOn>$(GetVsixSourceItemsDependsOn);AssignProjectConfiguration;DetokenizeVsixManifestFile;ZipProjects;ZipItems</GetVsixSourceItemsDependsOn>
    <CreateVsixContainerDependsOn>$(CreateVsixContainerDependsOn);GetVsixSourceItems</CreateVsixContainerDependsOn>

    <!--By default, only include items necessary for executing. 
        Exclude debug symbols & documentation files.-->
    <IncludeAssemblyInVSIXContainer Condition="'$(IncludeAssemblyInVSIXContainer)'==''">true</IncludeAssemblyInVSIXContainer>
    <IncludeAddModulesInVSIXContainer Condition="'$(IncludeAddModulesInVSIXContainer)'==''">true</IncludeAddModulesInVSIXContainer>
    <IncludeSGenDllInVSIXContainer Condition="'$(IncludeSGenDllInVSIXContainer)'==''">true</IncludeSGenDllInVSIXContainer>
    <IncludeDebugSymbolsInVSIXContainer Condition="'$(IncludeDebugSymbolsInVSIXContainer)'==''">false</IncludeDebugSymbolsInVSIXContainer>
    <IncludeDebugSymbolsInLocalVSIXDeployment Condition="'$(IncludeDebugSymbolsInLocalVSIXDeployment)'==''">true</IncludeDebugSymbolsInLocalVSIXDeployment>
    <IncludeDocFilesInVSIXContainer Condition="'$(IncludeDocFilesInVSIXContainer)'==''">false</IncludeDocFilesInVSIXContainer>
    <IncludeSatelliteAssembliesInVSIXContainer Condition="'$(IncludeSatelliteAssembliesInVSIXContainer)'==''">true</IncludeSatelliteAssembliesInVSIXContainer>
    <IncludeCOMReferencesInVSIXContainer Condition="'$(IncludeCOMReferencesInVSIXContainer)'==''">true</IncludeCOMReferencesInVSIXContainer>
    <IncludeCopyLocalReferencesInVSIXContainer Condition="'$(IncludeCopyLocalReferencesInVSIXContainer)'==''">true</IncludeCopyLocalReferencesInVSIXContainer>
    <IncludePkgdefInVSIXContainer Condition="'$(IncludePkgdefInVSIXContainer)'==''">true</IncludePkgdefInVSIXContainer>
  </PropertyGroup>

  <Target
      Name="GetVsixSourceItems"
      DependsOnTargets="$(GetVsixSourceItemsDependsOn)">

    <ItemGroup Condition="'$(IncludeAssemblyInVSIXContainer)'=='true'">
      <!--Create an item for the primary output of the project-->
      <VSIXSourceItem Include="@(IntermediateAssembly)">
        <VSIXSubPath>$(AssemblyVSIXSubPath)</VSIXSubPath>
      </VSIXSourceItem>
    </ItemGroup>

    <ItemGroup Condition="'$(IncludeAddModulesInVSIXContainer)'=='true'">
      <VSIXSourceItem Include="@(AddModules)">
        <VSIXSubPath>$(AssemblyVSIXSubPath)</VSIXSubPath>
      </VSIXSourceItem>
    </ItemGroup>

    <ItemGroup Condition="'$(IncludeSGenDllInVSIXContainer)'=='true' AND '$(_SGenDllCreated)'=='true'">
      <VSIXSourceItem Include="$(IntermediateOutputPath)$(_SGenDllName)">
        <VSIXSubPath>$(AssemblyVSIXSubPath)</VSIXSubPath>
      </VSIXSourceItem>
    </ItemGroup>

    <ItemGroup>
      <VSIXSourceItem Condition="'$(IncludeDebugSymbolsInVSIXContainer)'=='true'" Include="@(_DebugSymbolsIntermediatePath)">
        <VSIXSubPath>$(AssemblyVSIXSubPath)</VSIXSubPath>
      </VSIXSourceItem>

      <VSIXSourceItemLocalOnly Include="@(_DebugSymbolsIntermediatePath)" Condition="'$(IncludeDebugSymbolsInLocalVSIXDeployment)'=='true'">
        <VSIXSubPath>$(AssemblyVSIXSubPath)</VSIXSubPath>
      </VSIXSourceItemLocalOnly>
    </ItemGroup>

    <ItemGroup Condition="'$(IncludeDocFilesInVSIXContainer)'=='true'">
      <VSIXSourceItem Include="@(DocFileItem)">
        <VSIXSubPath>$(AssemblyVSIXSubPath)</VSIXSubPath>
      </VSIXSourceItem>
    </ItemGroup>

    <ItemGroup Condition="'$(IncludeSatelliteAssembliesInVSIXContainer)'=='true'">
      <VSIXSourceItem Include="@(IntermediateSatelliteAssembliesWithTargetPath->'$(OutDir)%(Culture)\$(TargetName).resources.dll')">
        <VSIXSubPath>$(AssemblyVSIXSubPath)</VSIXSubPath>
      </VSIXSourceItem>
    </ItemGroup>

    <ItemGroup Condition="'$(IncludeCOMReferencesInVSIXContainer)'=='true'">
      <VSIXSourceItem Include="@(ReferenceComWrappersToCopyLocal); @(ResolvedIsolatedComModules); @(_DeploymentLooseManifestFile); @(NativeReferenceFile)">
        <VSIXSubPath>$(AssemblyVSIXSubPath)</VSIXSubPath>
      </VSIXSourceItem>
    </ItemGroup>

    <ItemGroup Condition="'$(IncludeCopyLocalReferencesInVSIXContainer)'=='true'">
      <VSIXCopyLocalReferenceSourceItem Include="@(ReferencePath)">
        <VSIXSubPath Condition="'%(ReferencePath.VSIXSubPath)' == ''">$(AssemblyVSIXSubPath)</VSIXSubPath>
      </VSIXCopyLocalReferenceSourceItem>
    </ItemGroup>

    <CreateVsixSourceItemFromReferences ReferencedVSIXSourceItems="@(VSIXCopyLocalReferenceSourceItem)">
      <Output TaskParameter="VsixSourceItems" ItemName="VSIXSourceItem" />
    </CreateVsixSourceItemFromReferences>

    <ItemGroup Condition="'$(IncludePkgdefInVSIXContainer)'=='true' AND '$(GeneratePkgDefFile)'=='true'">
      <!--Create an item for the pkgdef output of the project-->
      <VSIXSourceItem Include="$(IntermediateOutputPath)$(TargetName).pkgdef">
        <VSIXSubPath>$(PkgdefVSIXSubPath)</VSIXSubPath>
      </VSIXSourceItem>
    </ItemGroup>

    <!-- Include the detokenized VSIX Manifest file-->
    <ItemGroup>
      <VSIXSourceItem Include="$(IntermediateVsixManifest)" />
    </ItemGroup>

    <!-- Include any Content items marked with IncludeInVSIX=true -->
    <ItemGroup>

      <VSIXSourceItem Include="@(Content)" Condition="'%(Content.IncludeInVSIX)'=='true' AND '%(Content.VSIXSubPath)'==''">
        <!-- Sets VSIXSubPath for content items that are nonlinked files -->
        <VSIXSubPath Condition="'%(Content.Link)'==''">%(Content.RelativeDir)</VSIXSubPath>
        <!-- Sets VSIXSubPath for content items that are linked files -->
        <VSIXSubPath Condition="'%(Content.Link)'!=''">$([System.IO.Path]::GetDirectoryName(%(Content.Link)))</VSIXSubPath>
      </VSIXSourceItem>

      <VSIXSourceItem Include="@(Content)" Condition="'%(Content.IncludeInVSIX)'=='true' AND '%(Content.VSIXSubPath)'!=''" />

    </ItemGroup>


    <!-- For any project references that are set to copy local ('Private' property != false), add the output groups for project references that are not set -->
    <ItemGroup>
      <ProjectReferenceWithConfiguration Condition="'%(ProjectReferenceWithConfiguration.Private)' != 'false' AND 
                                                    '%(ProjectReferenceWithConfiguration.IncludeOutputGroupsInVSIX)' == '' AND 
                                                    '%(ProjectReferenceWithConfiguration.IncludeOutputGroupsInVSIXLocalOnly)' == ''">
        <IncludeOutputGroupsInVSIX>BuiltProjectOutputGroup;BuiltProjectOutputGroupDependencies;GetCopyToOutputDirectoryItems</IncludeOutputGroupsInVSIX>
        <IncludeOutputGroupsInVSIXLocalOnly>DebugSymbolsProjectOutputGroup;</IncludeOutputGroupsInVSIXLocalOnly>
      </ProjectReferenceWithConfiguration>
    </ItemGroup>

    <!-- SplitIncludeOutputGroupsInVSIX will duplicate the project references into two lists. Each list is essentially a duplicate of the input.

         The IncludeOutputGroupsInVSIX values on items in the FilteredGroups list will only be BuiltProjectOutputGroupDependencies.
         The IncludeOutputGroupsInVSIX values on items in the UnfilteredGroups list will only be all other output groups.
         
         This is done because we only want to filter out items in the CreateVsixSourceItemFromReferences task that were build dependencies to
         avoid unintentially excluding output groups explicitly requested in IncludeOutputGroupsInVSIX.
         
         The task properly handles escaped values for IncludeOutputGroupsInVSIX (e.g. Target1%3bTarget2).
    -->

    <SplitIncludeOutputGroupsInVSIX ProjectReferences="@(ProjectReferenceWithConfiguration)"
                                    Condition="'%(ProjectReferenceWithConfiguration.IncludeOutputGroupsInVSIX)' != ''"
                                    OutputGroupFilter="BuiltProjectOutputGroupDependencies">
      <Output TaskParameter="FilteredGroups" ItemName="_ProjectReferenceWithBuiltGroups"/>
      <Output TaskParameter="UnfilteredGroups" ItemName="_ProjectReferenceWithoutBuiltGroups"/>
    </SplitIncludeOutputGroupsInVSIX>

    <!-- Build and include output for any Project Reference items marked where IncludeOutputGroupsInVSIX is set -->
    <MSBuild Projects="@(_ProjectReferenceWithBuiltGroups)"
             Properties="%(_ProjectReferenceWithBuiltGroups.SetConfiguration); %(_ProjectReferenceWithBuiltGroups.SetPlatform)"
             Targets="%(_ProjectReferenceWithBuiltGroups.IncludeOutputGroupsInVSIX)"
             Condition="'%(_ProjectReferenceWithBuiltGroups.IncludeOutputGroupsInVSIX)' != ''"
             RebaseOutputs="true">
      <Output TaskParameter="TargetOutputs" ItemName="ReferencedVSIXSourceItem"/>
    </MSBuild>

    <CreateVsixSourceItemFromReferences ReferencedVSIXSourceItems="@(ReferencedVSIXSourceItem)">
      <Output TaskParameter="VsixSourceItems" ItemName="VSIXSourceItem" />
    </CreateVsixSourceItemFromReferences>

    <MSBuild Projects="@(_ProjectReferenceWithoutBuiltGroups)"
             Properties="%(_ProjectReferenceWithoutBuiltGroups.SetConfiguration); %(_ProjectReferenceWithoutBuiltGroups.SetPlatform)"
             Targets="%(_ProjectReferenceWithoutBuiltGroups.IncludeOutputGroupsInVSIX)"
             Condition="'%(_ProjectReferenceWithoutBuiltGroups.IncludeOutputGroupsInVSIX)' != ''"
             RebaseOutputs="true">
      <Output TaskParameter="TargetOutputs" ItemName="VSIXSourceItem"/>
    </MSBuild>

    <!-- Build and include output for any Project Reference items marked where IncludeOutputGroupsInVSIXLocalOnly is set in the locally deployed vsix -->
    <!-- Unescape the targets because they may be escaped when added from the ExtensibilityProjectFlavor in VS. -->
    <MSBuild Projects="@(ProjectReferenceWithConfiguration)"
             Properties="%(ProjectReferenceWithConfiguration.SetConfiguration); %(ProjectReferenceWithConfiguration.SetPlatform)"
             Targets="$([MSBuild]::Unescape(%(ProjectReferenceWithConfiguration.IncludeOutputGroupsInVSIXLocalOnly)))"
             Condition="'%(ProjectReferenceWithConfiguration.IncludeOutputGroupsInVSIXLocalOnly)' != ''"
             RebaseOutputs="true">
      <Output TaskParameter="TargetOutputs" ItemName="VSIXSourceItemLocalOnly"/>
    </MSBuild>

    <ItemGroup>
      <!-- Sets VSIXSubPath for template references (template projects output has TemplateSubPath set on items) -->
      <VSIXSourceItem>
        <VSIXSubPath Condition="'%(VSIXSourceItem.TemplateSubPath)'!=''">%(VSIXSourceItem.VSIXSubPath)\%(VSIXSourceItem.TemplateSubPath)</VSIXSubPath>
      </VSIXSourceItem>
      <VSIXSourceItemLocalOnly>
        <VSIXSubPath Condition="'%(VSIXSourceItemLocalOnly.TemplateSubPath)'!=''">%(VSIXSourceItemLocalOnly.VSIXSubPath)\%(VSIXSourceItemLocalOnly.TemplateSubPath)</VSIXSubPath>
      </VSIXSourceItemLocalOnly>
    </ItemGroup>
  </Target>

  <Target
      Name="CreateVsixContainer"
      Condition="$(CreateVsixContainer)"
      Inputs="@(VSIXSourceItem)"
      Outputs="$(TargetVsixContainer)"
      DependsOnTargets="$(CreateVsixContainerDependsOn)">

    <Message Importance="High" Text="Creating VSIX Container..." />

    <CreateZipPackage
         Files="@(VSIXSourceItem)"
         ZipPackage="$(TargetVsixContainer)">
      <Output TaskParameter="ZipPackage" ItemName="FileWrites" />
      <Output TaskParameter="ZipPackage" ItemName="_CreatedVsixContainer" />
    </CreateZipPackage>

    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; @(_CreatedVsixContainer->'%(FullPath)')" />
  </Target>


  <!--
    =======================================================================================================
                                         Get Vsix Deployment Path
    =======================================================================================================
  -->
  <PropertyGroup>
    <GetVsixDeploymentPathDependsOn>$(GetVsixDeploymentPathDependsOn);DetokenizeVsixManifestFile</GetVsixDeploymentPathDependsOn>
  </PropertyGroup>

  <Target
      Name="GetVsixDeploymentPath"
      Condition="'$(DeployExtension)'=='true'"
      DependsOnTargets="$(GetVsixDeploymentPathDependsOn)">

    <GetExtensionsPath SubPath="$(ExtensionsDeploymentSubPath)">
      <Output TaskParameter="LocalExtensionsPath" PropertyName="ExtensionsPath"/>
    </GetExtensionsPath>

    <GetDeploymentPathFromVsixManifest
        Condition="Exists('$(IntermediateVsixManifest)')"
        ExtensionsPath="$(ExtensionsPath)"
        VsixManifest="$(IntermediateVsixManifest)" >
      <Output TaskParameter="DeploymentPath" PropertyName="VsixDeploymentPath"/>
      <Output TaskParameter="VsixID" PropertyName="VsixID"/>
      <Output TaskParameter="VsixVersion" PropertyName="VsixVersion"/>
    </GetDeploymentPathFromVsixManifest>
  </Target>

  <!--
    =======================================================================================================
                                         Deploy Vsix Extension Files
    =======================================================================================================
  -->
  <PropertyGroup>
    <DeployVsixExtensionFilesDependsOn>$(DeployVsixExtensionFilesDependsOn);GetVsixDeploymentPath;FindExistingDeploymentPath;GetVsixSourceItems</DeployVsixExtensionFilesDependsOn>
    <FindExistingDeploymentPathDependsOn>$(FindExistingDeploymentPathDependsOn);GetVsixDeploymentPath</FindExistingDeploymentPathDependsOn>
  </PropertyGroup>

  <Target Name="FindExistingDeploymentPath"
          Condition="'$(DeployExtension)'=='true'"
          DependsOnTargets="$(FindExistingDeploymentPathDependsOn)">
    <FindInstalledExtension
        VsixIdentifier="$(VsixID)"
        RootSuffix="$(VSSDKTargetPlatformRegRootSuffix)"
        FailIfNotInstalled="false">
      <Output TaskParameter="DeploymentPath" PropertyName="ExistingDeploymentPath" />
    </FindInstalledExtension>
  </Target>

  <Target Name="DeployVsixExtensionFiles"
      Condition="'$(DeployExtension)'=='true'"
      DependsOnTargets="$(DeployVsixExtensionFilesDependsOn)">

    <!-- Uninstall any existing extension with the same identifier with a different deployment path.
             We don't always call this because of the way Uninstall is implemented in Extension Manager.
             An uninstall operation just marks the directory for deletion in the registry and does the actual
             delete on the next instantiation of the Extension Manager service object. In our case, this happens
             at the same time (or just after) we are copying files to that directory. Therefore, we should only
             call uninstall if the existing installation directory is different than the one we're deploying files
             to. -->
    <UninstallExtension
        Condition="'$(ExistingDeploymentPath)' != '$(VsixDeploymentPath)' AND '$(ExistingDeploymentPath)' != ''"
        VsixIdentifier="$(VsixID)"
        RootSuffix="$(VSSDKTargetPlatformRegRootSuffix)"
        FailIfNotInstalled="false" />

    <Message Text="VsixID = $(VsixID)" />
    <Message Text="VsixVersion = $(VsixVersion)" />
    <Message Text="VsixDeploymentPath = $(VsixDeploymentPath)" />

    <ItemGroup>
      <VsixExtensionFiles Include="@(VSIXSourceItem);@(VSIXSourceItemLocalOnly)" />
    </ItemGroup>

    <!-- The TargetPath metadata contains the whole path, not just the directory -->

    <Copy
        SourceFiles="@(VsixExtensionFiles)"
        DestinationFiles="@(VsixExtensionFiles->'$(VsixDeploymentPath)%(VSIXSubPath)\%(Filename)%(Extension)')"
        Condition="'%(VsixExtensionFiles.TargetPath)'==''"
        SkipUnchangedFiles="true"
        OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
        Retries="$(CopyRetryCount)"
        RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)">
      <Output TaskParameter="DestinationFiles" ItemName="_VsixDeployCurrentFileWrites"/>
    </Copy>

    <Copy
        SourceFiles="@(VsixExtensionFiles)"
        DestinationFiles="@(VsixExtensionFiles->'$(VsixDeploymentPath)%(VSIXSubPath)\%(TargetPath)')"
        Condition="'%(VsixExtensionFiles.TargetPath)'!=''"
        SkipUnchangedFiles="true"
        OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
        Retries="$(CopyRetryCount)"
        RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)">
      <Output TaskParameter="DestinationFiles" ItemName="_VsixDeployCurrentFileWrites"/>
    </Copy>

    <!--Check if the user is an administrator and the user profile hasn't been setup for the target instance. -->
    <CheckProfileSetup
        RootSuffix="$(VSSDKTargetPlatformRegRootSuffix)">
      <Output TaskParameter="IsAdministrator" PropertyName="IsCurrentUserAdministrator" />
      <Output TaskParameter="IsProfileSetup" PropertyName="IsTargetProfileSetup" />
    </CheckProfileSetup>

    <!--Run devenv to setup the target profile if necessary -->
    <Message
        Importance="High"
        Text="Setting up Visual Studio for debugging extensions. This one-time operation may take a minute or more."
        Condition="'$(IsCurrentUserAdministrator)'=='True' And '$(IsTargetProfileSetup)'=='False'" />
    <Devenv
        Condition="'$(IsCurrentUserAdministrator)'=='True' And '$(IsTargetProfileSetup)'=='False'"
        RootSuffix="$(VSSDKTargetPlatformRegRootSuffix)"
        ResetSettingProfile="General.vssettings"
        IsEmbedded="true" />

    <!--Enable always loading extensions from LocalAppData -->
    <EnableLoadingAllExtensions
        RootSuffix="$(VSSDKTargetPlatformRegRootSuffix)" />

    <!--Enable this extension via Extension Manager-->
    <EnableExtension
        VsixIdentifier="$(VsixID)"
        RootSuffix="$(VSSDKTargetPlatformRegRootSuffix)"
        FailIfNotInstalled="true" />
  </Target>

  <!--
    =======================================================================================================
                                         Copy Vsix Extension Files

       Target to do a raw copy of extension files. Does not use Extension Manager API to 
       enable/manage an extension. Typically only used for Isolated Shell solutions.
    =======================================================================================================
  -->
  <PropertyGroup>
    <CopyVsixExtensionFilesDependsOn>$(CopyVsixExtensionFilesDependsOn);GetVsixSourceItems</CopyVsixExtensionFilesDependsOn>
  </PropertyGroup>
  <Target Name="CopyVsixExtensionFiles"
      Condition="'$(CopyVsixExtensionFiles)'=='true' AND '$(CopyVsixExtensionLocation)' != ''"
      DependsOnTargets="$(CopyVsixExtensionFilesDependsOn)">

    <ItemGroup>
      <CopyVsixExtensionFiles Include="@(VSIXSourceItem);@(VSIXSourceItemLocalOnly)" />
    </ItemGroup>

    <!-- The TargetPath metadata contains the whole path, not just the directory -->

    <Copy
        SourceFiles="@(CopyVsixExtensionFiles)"
        DestinationFiles="@(CopyVsixExtensionFiles->'$(CopyVsixExtensionLocation)\%(VSIXSubPath)\%(FileName)%(Extension)')"
        Condition="'%(CopyVsixExtensionFiles.TargetPath)' == ''"
        SkipUnchangedFiles="true"
        OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
        Retries="$(CopyRetryCount)"
        RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)">
      <Output TaskParameter="DestinationFiles" ItemName="_VsixDeployCurrentFileWrites"/>
    </Copy>

    <Copy
        SourceFiles="@(CopyVsixExtensionFiles)"
        DestinationFiles="@(CopyVsixExtensionFiles->'$(CopyVsixExtensionLocation)\%(VSIXSubPath)\%(TargetPath)')"
        Condition="'%(CopyVsixExtensionFiles.TargetPath)' != ''"
        SkipUnchangedFiles="true"
        OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
        Retries="$(CopyRetryCount)"
        RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)">
      <Output TaskParameter="DestinationFiles" ItemName="_VsixDeployCurrentFileWrites"/>
    </Copy>


  </Target>


  <!--
    ============================================================
             VSIXContainerProjectOutputGroup

      Used for determining the VSIX Container that this project
      builds from other projects that reference it.
    ============================================================
    -->
  <Target Name="VSIXContainerProjectOutputGroup"
          Outputs="@(VSIXContainerOutputGroupOutput)"
          DependsOnTargets="$(VSIXContainerProjectOutputGroupDependsOn)">

    <ItemGroup Condition="'$(CreateVsixContainer)'=='true'">
      <_VSIXContainerOutputGroupOutput Include="$(TargetVsixContainer)" />
    </ItemGroup>

    <ItemGroup Condition="'$(CreateVsixContainer)'=='true'">
      <VSIXContainerOutputGroupOutput Include="@(_VSIXContainerOutputGroupOutput->'%(FullPath)')" />
    </ItemGroup>
  </Target>

  <!--
    =======================================================================================================
                                                Run RegRiched20.exe
    =======================================================================================================
  -->
  <PropertyGroup>
    <PrepareForBuildDependsOn>
      $(PrepareForBuildDependsOn);
      RunRegRiched
    </PrepareForBuildDependsOn>
    <RunRegRichedDependsOn>$(RunRegRichedDependsOn);FindSDKInstallation</RunRegRichedDependsOn>
  </PropertyGroup>

  <Target Name="RunRegRiched"
         DependsOnTargets="$(RunRegRichedDependsOn)"
         Condition="'$(RunRegRiched)' == 'true'">
    <Warning
      Text="RegRiched20.exe was not found."
      Condition="!Exists('$(VsSDKInstall)VisualStudioIntegration\Tools\Bin\RegRiched20.exe')">
    </Warning>
    <Exec Command="&quot;$(VsSDKInstall)VisualStudioIntegration\Tools\Bin\RegRiched20.exe&quot;"
          ContinueOnError="true"
          Condition="Exists('$(VsSDKInstall)VisualStudioIntegration\Tools\Bin\RegRiched20.exe')">
    </Exec>
  </Target>

  <!--
    =======================================================================================================
    This target sets a property when the .cto file is newer than the previously built assembly.
    =======================================================================================================
  -->

  <Target Name="CheckCTOFileHasChanged"
          Inputs="@(VSCTCompile->'$(IntermediateOutputPath)%(FileName).cto')"
          Outputs="$(TargetPath)"
          DependsOnTargets="VSCTCompile">

    <CreateProperty Value="true">
      <Output PropertyName="CTOFileHasChanged"
              TaskParameter="ValueSetByTask" />
    </CreateProperty>
  </Target>


  <!--
    =======================================================================================================
                                              Merging CTO resource
    =======================================================================================================
  -->
  <PropertyGroup>
    <!-- The result of the VSCT compilation will be used by the resource generator, so this task
         must depend on the VSCT one -->
    <PrepareResourcesDependsOn>$(PrepareResourcesDependsOn);MergeCtoResource</PrepareResourcesDependsOn>
    <MergeCtoResourceDependsOn>$(MergeCtoResourceDependsOn);GenerateListOfCTO;VSCTCompile;CheckCTOFileHasChanged;GenerateResourceToMergeWithCTO</MergeCtoResourceDependsOn>
  </PropertyGroup>

  <!--
    Create the list of the .RESOURCES files to merge with the CTO data.
  -->
  <Target Name="GenerateResourceToMergeWithCTO"
          DependsOnTargets="ResGen">
    <ItemGroup>
      <_ResourcesToMergeWithCTO Include="%(EmbeddedResource.OutputResource)" Condition="'%(EmbeddedResource.MergeWithCTO)'=='true'"/>
    </ItemGroup>
    <AssignCulture Files="@(_ResourcesToMergeWithCTO)" >
      <!-- Create the list of resources with Culture metadata -->
      <Output TaskParameter="AssignedFiles" ItemName="_ResourcesToMergeWithCTOWithCultureMetadata"/>
    </AssignCulture>
  </Target>

  <!--
  Create the list of the expected CTO files.
  -->
  <Target Name="GenerateListOfCTO">
    <!--Add the CTO files from the list of VSCT files.-->
    <ItemGroup>
      <_GeneratedCTOFiles  Include="@(VSCTCompile->'$(IntermediateOutputPath)%(FileName).cto')" Condition="'@(VSCTCompile)' != ''"/>
    </ItemGroup>
    <AssignCulture Files="@(_GeneratedCTOFiles)" >
      <!-- Create the list of culture cto files -->
      <Output TaskParameter="AssignedFilesWithCulture" ItemName="_GeneratedCTOFilesWithCulture"/>
      <!-- Create the list of non-culture cto files -->
      <Output TaskParameter="AssignedFilesWithNoCulture" ItemName="_GeneratedCTOFilesWithNoCulture"/>
    </AssignCulture>
  </Target>

  <Target Name="MergeCtoResource"
          Condition="'@(VSCTCompile)' != '' AND '$(BuildingProject)'!='false'"
          DependsOnTargets="$(MergeCtoResourceDependsOn)">

    <CtoResourceMerger CtoFilesWithCulture="@(_GeneratedCTOFilesWithCulture)"
                       CtoFilesWithNoCulture="@(_GeneratedCTOFilesWithNoCulture)"
                       IntermediateDirectory="$(IntermediateOutputPath)"
                       ResourcesToMerge="@(_ResourcesToMergeWithCTOWithCultureMetadata)" >
      <Output TaskParameter="TemporaryFiles" ItemName="_TemporaryCtoResouceMergerFiles"/>
    </CtoResourceMerger>
    <ItemGroup>
      <FileWrites Include="@(_TemporaryCtoResouceMergerFiles)" />
    </ItemGroup>
  </Target>

  <!--
    =======================================================================================================
                                       Generate code from LEX files
    =======================================================================================================
  -->
  <PropertyGroup>
    <!--Make sure that the lexer runs before the C# compiler-->
    <CoreCompileDependsOn>$(CoreCompileDependsOn);GenerateCodeFromLex</CoreCompileDependsOn>
  </PropertyGroup>
  <!--
    TODO: When MPLex.exe will allow us to specify the name / path of the output file we should change this
    target to use custom output names and use @(MPLexCompile->'$(IntermediateOutputPath)%(FileName).cs')
    as default.
  -->
  <Target Name="GenerateCodeFromLex"
          Condition="'$(BuildingProject)'!='false'"
          Inputs="@(MPLexCompile);$(LexFrameFile)"
          Outputs="@(MPLexCompile->'$(IntermediateOutputPath)%(FileName).cs')"
          DependsOnTargets="$(GenerateCodeFromLexDependsOn)">

    <MPLex InputFile="@(MPLexCompile)"
           OutputFile="@(MPLexCompile->'$(IntermediateOutputPath)%(FileName).cs')"
           CompressTables="$(CompressTables)"
           FrameFile="$(LexFrameFile)"
           SDKVersion="$(VsSDKVersion)">
      <Output TaskParameter="OutputFile" ItemName="Compile" />
      <Output TaskParameter="OutputFile" ItemName="FileWrites"/>
    </MPLex>

  </Target>

  <!--
    =======================================================================================================
                                      Generate parser code from Y files
    =======================================================================================================
  -->
  <PropertyGroup>
    <GenerateParserCodeFromGrammarDependsOn>$(GenerateParserCodeFromGrammarDependsOn);FindSDKInstallation</GenerateParserCodeFromGrammarDependsOn>
    <CoreCompileDependsOn>$(CoreCompileDependsOn);GenerateParserCodeFromGrammar</CoreCompileDependsOn>
  </PropertyGroup>
  <Target Name="GenerateParserCodeFromGrammar"
          Condition="'$(BuildingProject)'!='false'"
          Inputs="@(MPPGCompile)"
          Outputs="@(MPPGCompile->'$(IntermediateOutputPath)%(FileName).cs')"
          DependsOnTargets="$(GenerateParserCodeFromGrammarDependsOn)">

    <!--Check if there are .lex files in the project because in this case mppg should generate the base classes
        used by the code generated by MPLex-->
    <CreateProperty Value="-mplex" Condition="'@(MPLexCompile)' != ''">
      <Output TaskParameter="ValueSetByTask" PropertyName="__GenerateForMPLex" />
    </CreateProperty>

    <!--Run the command line tool that generates the cs files.-->
    <Exec Command="&quot;$(VsSDKToolsPath)\MPPG.exe&quot; $(__GenerateForMPLex) @(MPPGCompile->'&quot;%(Identity)&quot;') > @(MPPGCompile->'&quot;$(IntermediateOutputPath)%(FileName).cs&quot;')" />

    <!--Add the generated files to the list of the files to compile.-->
    <CreateItem Include="@(MPPGCompile->'$(IntermediateOutputPath)%(FileName).cs')">
      <Output TaskParameter="Include" ItemName="Compile" />
      <Output TaskParameter="Include" ItemName="FileWrites"/>
    </CreateItem>
  </Target>

  <!--
    =======================================================================================================
                                         Generating PkgDef File
    =======================================================================================================
  -->
  <PropertyGroup>
    <PrepareForRunDependsOn>
      $(PrepareForRunDependsOn);
      GeneratePkgDef;
      CopyPkgDef;
      CreateVsixContainer;
      DeployVsixExtensionFiles;
      CopyVsixManifestFile;
      CopyVsixExtensionFiles;
    </PrepareForRunDependsOn>
    <GeneratePkgDefDependsOn>$(GeneratePkgDefDependsOn);Compile</GeneratePkgDefDependsOn>
    <GeneratePkgDefFile Condition="'$(GeneratePkgDefFile)' == ''">true</GeneratePkgDefFile>
    <UseCodebase Condition="'$(UseCodebase)' == ''">$(RegisterWithCodebase)</UseCodebase>
  </PropertyGroup>

  <Target Name="GeneratePkgDef"
          Inputs="$(TargetPath)"
          Outputs="$(IntermediateOutputPath)$(TargetName).pkgdef"
          Condition="'$(GeneratePkgDefFile)'=='true'"
          DependsOnTargets="$(GeneratePkgDefDependsOn)">

    <Message Importance="High" Text="Creating intermediate PkgDef file." />

    <CreatePkgDef AssemblyToProcess="$(TargetPath)"
              ProductVersion="$(TargetVSVersion)"
              SDKVersion="$(VsSDKVersion)"
              OutputFile="$(IntermediateOutputPath)$(TargetName).latest.pkgdef"
              UseCodebase="$(UseCodebase)" 
              ReferencedAssemblies="@(ReferencePath)"  />
    <CopyIfChanged Condition="Exists('$(IntermediateOutputPath)$(TargetName).latest.pkgdef')"
                   SourceFile="$(IntermediateOutputPath)$(TargetName).latest.pkgdef"
                   DestinationFile="$(IntermediateOutputPath)$(TargetName).pkgdef" />
    <ItemGroup>
      <FileWrites Include="$(IntermediateOutputPath)$(TargetName).pkgdef" Condition="Exists('$(IntermediateOutputPath)$(TargetName).pkgdef')"/>
      <FileWrites Include="$(IntermediateOutputPath)$(TargetName).latest.pkgdef" Condition="Exists('$(IntermediateOutputPath)$(TargetName).latest.pkgdef')"/>
    </ItemGroup>
  </Target>


  <!--
    =======================================================================================================
                                         PkgdefProjectOutputGroup

      Used for determining the Pkgdef file that this project creates from another project
    =======================================================================================================
  -->
  <Target Name="PkgdefProjectOutputGroup"
        Outputs="@(PkgdefOutputGroupOutput)"
        DependsOnTargets="$(PkgdefProjectOutputGroupDependsOn)">

    <ItemGroup Condition="'$(GeneratePkgDefFile)'=='true'">
      <_PkgdefOutputGroupOutput Include="$(IntermediateOutputPath)$(TargetName).pkgdef" />
    </ItemGroup>

    <ItemGroup Condition="'$(GeneratePkgDefFile)'=='true'">
      <PkgdefOutputGroupOutput Include="@(_PkgdefOutputGroupOutput->'%(FullPath)')" />
    </ItemGroup>

  </Target>

  <!--
    =======================================================================================================
                                         TemplateProjectOutputGroup

      Used for determining the template zip file(s) that this project builds from another project
    =======================================================================================================
  -->
  <PropertyGroup>
    <TemplateProjectOutputGroupDependsOn>
      $(TemplateProjectOutputGroupDependsOn);
      GetZipFilesFromVSTemplates;
      CalculateZipFiles
    </TemplateProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="TemplateProjectOutputGroup"
        Outputs="@(TemplateOutputGroupOutput)"
        DependsOnTargets="$(TemplateProjectOutputGroupDependsOn)">

    <ItemGroup>
      <_TemplateOutputGroupOutput Include="@(_ZipProject->'%(ZipFile)')" >
        <TemplateSubPath>%(_ZipProject.Language)\%(_ZipProject.OutputSubPath)\%(_ZipProject.Culture)</TemplateSubPath>
      </_TemplateOutputGroupOutput>

      <_TemplateOutputGroupOutput Include="@(_ZipItem->'%(ZipFile)')" >
        <TemplateSubPath>%(_ZipItem.Language)\%(_ZipItem.OutputSubPath)\%(_ZipItem.Culture)</TemplateSubPath>
      </_TemplateOutputGroupOutput>
    </ItemGroup>

    <ItemGroup>
      <TemplateOutputGroupOutput Include="@(_TemplateOutputGroupOutput->'%(FullPath)')" />
    </ItemGroup>

  </Target>

  <!--
    =======================================================================================================
    This target contains 2 tasks to copy the .pkgdef file only when necessary. 
    =======================================================================================================
  -->

  <PropertyGroup>
    <CopyPkgDefDependsOn>$(CopyPkgDefDependsOn);GeneratePkgDef;CheckCTOFileHasChanged</CopyPkgDefDependsOn>
  </PropertyGroup>

  <Target Name="CopyPkgDef"
          Inputs="$(IntermediateOutputPath)$(TargetName).pkgdef"
          Outputs="$(OutDir)$(TargetName).pkgdef"
          Condition="'$(GeneratePkgDefFile)'=='true'"
          DependsOnTargets="$(CopyPkgDefDependsOn)">

    <!--
      =======================================================================================================
      This task copies the .pkgdef file to the target directory when the .cto file has changed. 
      Even though the .pkgdef file contents might have not changed, the new timestamp on the .pkgdef file
      will cause Visual Studio to re-merge menus on next launch.
      =======================================================================================================
    -->
    <Copy Condition="'$(CTOFileHasChanged)'=='true'"
          SourceFiles="$(IntermediateOutputPath)$(TargetName).pkgdef"
          DestinationFiles="$(OutDir)$(TargetName).pkgdef"
          SkipUnchangedFiles="false"
          OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
          Retries="$(CopyRetryCount)"
          RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
    </Copy>

    <!--
      =======================================================================================================
      This target copies the .pkgdef file to the target directory only if its contents have changed.
      This is an optimization to avoid rebuilding the PkgDef cache if this .pkgdef has not really changed.
      =======================================================================================================
    -->
    <CopyIfChanged Condition="'$(CTOFileHasChanged)'!='true'"
                   SourceFile="$(IntermediateOutputPath)$(TargetName).pkgdef"
                   DestinationFile="$(OutDir)$(TargetName).pkgdef" >
      <Output TaskParameter="DestinationFile" ItemName="FileWrites"/>
    </CopyIfChanged>

  </Target>

  <!--
    =======================================================================================================
                                         Creating Zip Files
    =======================================================================================================
  -->

  <PropertyGroup>
    <PrepareForRunDependsOn>
      ZipProjects;
      ZipItems;
      $(PrepareForRunDependsOn)
    </PrepareForRunDependsOn>
    <ZipFilesDependsOn>VsTemplatePathsTarget;GetZipFilesFromVSTemplates;CalculateZipFiles</ZipFilesDependsOn>
  </PropertyGroup>

  <!--Make sure that the zip output is set-->
  <PropertyGroup>
    <ZipProjectOutput Condition="'$(ZipProjectOutput)' == ''">$(OutputPath)</ZipProjectOutput>
    <ZipItemOutput Condition="'$(ZipItemOutput)' == ''">$(OutputPath)</ZipItemOutput>
    <ZipIntermediatePath Condition="'$(ZipIntermediatePath)' == ''">$(IntermediateOutputPath)</ZipIntermediatePath>
    <CopyZipOutputToOutputDirectory Condition="'$(CopyZipOutputToOutputDirectory)'==''">true</CopyZipOutputToOutputDirectory>
  </PropertyGroup>

  <Target Name="GetZipFilesFromVSTemplates"
          Condition="'@(VSTemplate)'!=''" >
    <GetVSTemplateItems
      TemplateFiles="@(VSTemplate)"
      TargetPath="$(ZipIntermediatePath)">
      <Output TaskParameter="ZipItems" ItemName="_ZipItem" />
      <Output TaskParameter="ZipProjects" ItemName="_ZipProject" />
    </GetVSTemplateItems>
  </Target>

  <Target Name="CalculateZipFiles"
          Condition="'@(ZipProject)_@(ZipItem)' != '_'">
    <!--The purpose of this target is to calculate the intermediate path for each ZipProject/ZipItem
      Normally, something like this can be done in a MSBuild Transform, but this is a little more complicated
      for ZipItems/Projects, so we need a custom task-->

    <!--Project using RootPath-->
    <CalculateZipItems
        Condition="'%(ZipProject.RootPath)'!='' AND '@(ZipProject)' != ''"
        Files="@(ZipProject)"
        ProjectPath="$(MSBuildProjectDirectory)"
        ZipName="%(ZipProject.RootPath)"
        TargetPath="$(ZipIntermediatePath)">
      <Output
        TaskParameter="Files"
        ItemName="_ZipProject" />
    </CalculateZipItems>

    <!--Project using Directory-->
    <CalculateZipItems
        Condition="'%(ZipProject.RootPath)'=='' AND '@(ZipProject)' != ''"
        Files="@(ZipProject)"
        ProjectPath="$(MSBuildProjectDirectory)"
        ZipName="%(ZipProject.Directory)"
        TargetPath="$(ZipIntermediatePath)" >
      <Output
        TaskParameter="Files"
        ItemName="_ZipProject" />
    </CalculateZipItems>

    <!--Item using RootPath-->
    <CalculateZipItems
        Condition="'%(ZipItem.RootPath)'!='' AND '@(ZipItem)' != ''"
        Files="@(ZipItem)"
        ProjectPath="$(MSBuildProjectDirectory)"
        ZipName="%(ZipItem.RootPath)"
        TargetPath="$(ZipIntermediatePath)">
      <Output
        TaskParameter="Files"
        ItemName="_ZipItem" />
    </CalculateZipItems>

    <!--Item using Directory-->
    <CalculateZipItems
        Condition="'%(ZipItem.RootPath)'=='' AND '@(ZipItem)' != ''"
        Files="@(ZipItem)"
        ProjectPath="$(MSBuildProjectDirectory)"
        ZipName="%(ZipItem.Directory)"
        TargetPath="$(ZipIntermediatePath)"
        >
      <Output
        TaskParameter="Files"
        ItemName="_ZipItem" />
    </CalculateZipItems>
  </Target>

  <Target Name="ZipProjects"
         DependsOnTargets="$(ZipFilesDependsOn)"
         Condition="'@(_ZipProject)' != '_'">
    <Message Text="Zipping ProjectTemplates"/>
    <!--
      There are 2 options for using this task:
        1) specifying a rootpath on each item
        2) using the directory of the item as the rootpath

      Note: the name of the zip file will be based on the rootpath
    -->
    <!--Project using RootPath-->
    <ZipItems
        Condition="'%(_ZipProject.RootPath)'!='' AND '@(_ZipProject)' != ''"
        Files="@(_ZipProject)"
        Action="New"
        OutputSubPath="%(_ZipProject.OutputSubPath)"
        Culture="%(_ZipProject.Culture)"
        ProjectPath="$(MSBuildProjectDirectory)"
        RootPath="$(MSBuildProjectDirectory)\%(_ZipProject.RootPath)"
        ZipDefaultLanguage="$(VsTemplateLanguage)"
        ZipLanguage="%(_ZipProject.Language)"
        ZipFile="%(_ZipProject.ZipFile)">
      <Output TaskParameter="ZipFile" ItemName="IntermediateZipProject"/>
      <Output TaskParameter="ZipFile" ItemName="FileWrites"/>
    </ZipItems>

    <!--Project using Directory-->
    <ZipItems
        Condition="'%(_ZipProject.RootPath)'=='' AND '@(_ZipProject)' != ''"
        Files="@(_ZipProject)"
        Action="New"
        OutputSubPath="%(_ZipProject.OutputSubPath)"
        Culture="%(_ZipProject.Culture)"
        ProjectPath="$(MSBuildProjectDirectory)"
        RootPath="%(_ZipProject.RootDir)%(_ZipProject.Directory)"
        ZipDefaultLanguage="$(VsTemplateLanguage)"
        ZipLanguage="%(_ZipProject.Language)"
        ZipFile="%(_ZipProject.ZipFile)">
      <Output TaskParameter="ZipFile" ItemName="IntermediateZipProject"/>
      <Output TaskParameter="ZipFile" ItemName="FileWrites"/>
    </ZipItems>

    <!--
      Copy the generated templates to the deployment folder.
    -->
    <Copy SourceFiles="@(IntermediateZipProject)"
          DestinationFiles="@(IntermediateZipProject->'$(ZipProjectOutput)\%(Language)\%(OutputSubPath)\%(Culture)\%(FileName)%(Extension)')"
          SkipUnchangedFiles="true"
          OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
          Retries="$(CopyRetryCount)"
          RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
          Condition="'$(DeployVSTemplates)'=='true'" />

    <!--
      Copy the generated templates to the output folder.
    -->
    <Copy SourceFiles="@(IntermediateZipProject)"
          DestinationFiles="@(IntermediateZipProject->'$(OutDir)\ProjectTemplates\%(Language)\%(OutputSubPath)\%(Culture)\%(FileName)%(Extension)')"
          SkipUnchangedFiles="true"
          OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
          Retries="$(CopyRetryCount)"
          RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
          Condition="'$(CopyZipOutputToOutputDirectory)'=='true'" >
      <Output TaskParameter="DestinationFiles" ItemName="_ZipProjectOutDir"/>
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
    </Copy>

    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; @(_ZipProjectOutDir->'%(FullPath)')" />

  </Target>

  <Target Name="ZipItems"
          DependsOnTargets="$(ZipFilesDependsOn)"
          Condition="'@(_ZipItem)' != '_'">

    <Message Text="Zipping ItemTemplates"/>

    <!--
      There are 2 options for using this task:
        1) specifying a rootpath on each item
        2) using the directory of the item as the rootpath

      Note: the name of the zip file will be based on the rootpath
    -->

    <!--Item using RootPath-->
    <ZipItems
        Condition="'%(_ZipItem.RootPath)'!='' AND '@(_ZipItem)' != ''"
        Files="@(_ZipItem)"
        Action="New"
        OutputSubPath="%(_ZipItem.OutputSubPath)"
        Culture="%(_ZipItem.Culture)"
        ProjectPath="$(MSBuildProjectDirectory)"
        RootPath="$(MSBuildProjectDirectory)\%(_ZipItem.RootPath)"
        ZipDefaultLanguage="$(VsTemplateLanguage)"
        ZipLanguage="%(_ZipItem.Language)"
        ZipFile="%(_ZipItem.ZipFile)">
      <Output TaskParameter="ZipFile" ItemName="IntermediateZipItem"/>
      <Output TaskParameter="ZipFile" ItemName="FileWrites"/>
    </ZipItems>

    <!--Item using Directory-->
    <ZipItems
        Condition="'%(_ZipItem.RootPath)'=='' AND '@(_ZipItem)' != ''"
        Files="@(_ZipItem)"
        Action="New"
        OutputSubPath="%(_ZipItem.OutputSubPath)"
        Culture="%(_ZipItem.Culture)"
        ProjectPath="$(MSBuildProjectDirectory)"
        RootPath="%(_ZipItem.RootDir)%(_ZipItem.Directory)"
        ZipDefaultLanguage="$(VsTemplateLanguage)"
        ZipLanguage="%(_ZipItem.Language)"
        ZipFile="%(_ZipItem.ZipFile)">
      <Output TaskParameter="ZipFile" ItemName="IntermediateZipItem"/>
      <Output TaskParameter="ZipFile" ItemName="FileWrites"/>
    </ZipItems>

    <!--
      Copy the generated templates to the deployment folder.
    -->
    <Copy SourceFiles="@(IntermediateZipItem)"
          DestinationFiles="@(IntermediateZipItem->'$(ZipItemOutput)\%(Language)\%(OutputSubPath)\%(Culture)\%(FileName)%(Extension)')"
          SkipUnchangedFiles="true"
          OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
          Retries="$(CopyRetryCount)"
          RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
          Condition="'$(DeployVSTemplates)'=='true'" />

    <!--
      Copy the generated templates to the output folder.
    -->
    <Copy SourceFiles="@(IntermediateZipItem)"
          DestinationFiles="@(IntermediateZipItem->'$(OutDir)\ItemTemplates\%(Language)\%(OutputSubPath)\%(Culture)\%(FileName)%(Extension)')"
          SkipUnchangedFiles="true"
          OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
          Retries="$(CopyRetryCount)"
          RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
          Condition="'$(CopyZipOutputToOutputDirectory)'=='true'" >
      <Output TaskParameter="DestinationFiles" ItemName="_ZipItemOutDir"/>
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
    </Copy>

    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; @(_ZipItemOutDir->'%(FullPath)')" />

  </Target>
  
  <!--Provide support for setting type (BuildAction) to ZipProject/ZipItem from VS-->
  <ItemGroup>
    <AvailableItemName Include="VSTemplate"/>
    <AvailableItemName Include="ZipProject"/>
    <AvailableItemName Include="ZipItem"/>
  </ItemGroup>

  <!--Target to retrive deployment path for vstemplates zip files-->
  <Target Name="VsTemplatePathsTarget"
          DependsOnTargets="$(VsTemplatePathsTargetDependsOn)"
          Condition="'$(DeployVSTemplates)'=='true'">

    <VsTemplatePaths RegistryHive="$(VSSDKTargetPlatformRegRoot)$(VSSDKTargetPlatformRegRootSuffix)">
      <Output TaskParameter="ProjectTemplates" PropertyName="ZipProjectOutput"/>
      <Output TaskParameter="ItemTemplates" PropertyName="ZipItemOutput"/>
    </VsTemplatePaths>

    <!--Make sure those directories exist-->
    <MakeDir Directories="$(ZipProjectOutput);$(ZipItemOutput)"/>
  </Target>

</Project>
